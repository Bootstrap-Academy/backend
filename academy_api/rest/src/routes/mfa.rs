use std::sync::Arc;

use academy_core_mfa_contracts::{
    MfaDisableError, MfaEnableError, MfaFeatureService, MfaInitializeError,
};
use academy_models::mfa::TotpCode;
use aide::{
    axum::{routing, ApiRouter},
    transform::TransformOperation,
};
use axum::{
    extract::{Path, State},
    http::StatusCode,
    response::{IntoResponse, Response},
    Json,
};
use schemars::JsonSchema;
use serde::Deserialize;

use super::user::UserNotFoundError;
use crate::{
    docs::TransformOperationExt,
    error_code,
    errors::{auth_error, auth_error_docs, internal_server_error, internal_server_error_docs},
    extractors::auth::ApiToken,
    models::{user::PathUserIdOrSelf, OkResponse},
};

pub const TAG: &str = "MFA";

pub fn router(service: Arc<impl MfaFeatureService>) -> ApiRouter<()> {
    ApiRouter::new()
        .api_route(
            "/auth/users/:user_id/mfa",
            routing::post_with(initialize, initialize_docs)
                .put_with(enable, enable_docs)
                .delete_with(disable, disable_docs),
        )
        .with_state(service)
        .with_path_items(|op| op.tag(TAG))
}

async fn initialize(
    service: State<Arc<impl MfaFeatureService>>,
    token: ApiToken,
    Path(PathUserIdOrSelf { user_id }): Path<PathUserIdOrSelf>,
) -> Response {
    match service.initialize(&token.0, user_id.into()).await {
        Ok(setup) => Json(setup.secret).into_response(),
        Err(MfaInitializeError::AlreadyEnabled) => MfaAlreadyEnabledError.into_response(),
        Err(MfaInitializeError::NotFound) => UserNotFoundError.into_response(),
        Err(MfaInitializeError::Auth(err)) => auth_error(err),
        Err(MfaInitializeError::Other(err)) => internal_server_error(err),
    }
}

fn initialize_docs(op: TransformOperation) -> TransformOperation {
    op.summary("Initialize MFA for the given user.")
        .description(
            "Generates and returns a new TOTP secret, which should be used to configure the \
             user's MFA authenticator.",
        )
        .add_response_with::<String>(StatusCode::OK, "MFA has been initialized.", |op| {
            op.example("randomtotpsecret")
        })
        .add_error::<MfaAlreadyEnabledError>()
        .add_error::<UserNotFoundError>()
        .with(auth_error_docs)
        .with(internal_server_error_docs)
}

#[derive(Deserialize, JsonSchema)]
struct EnableRequest {
    /// TOTP code generated by the MFA authenticator
    code: TotpCode,
}

async fn enable(
    service: State<Arc<impl MfaFeatureService>>,
    token: ApiToken,
    Path(PathUserIdOrSelf { user_id }): Path<PathUserIdOrSelf>,
    Json(EnableRequest { code }): Json<EnableRequest>,
) -> Response {
    match service.enable(&token.0, user_id.into(), code).await {
        Ok(recovery_code) => Json(recovery_code).into_response(),
        Err(MfaEnableError::AlreadyEnabled) => MfaAlreadyEnabledError.into_response(),
        Err(MfaEnableError::NotInitialized) => MfaNotInitializedError.into_response(),
        Err(MfaEnableError::InvalidCode) => InvalidMfaCodeError.into_response(),
        Err(MfaEnableError::NotFound) => UserNotFoundError.into_response(),
        Err(MfaEnableError::Auth(err)) => auth_error(err),
        Err(MfaEnableError::Other(err)) => internal_server_error(err),
    }
}

fn enable_docs(op: TransformOperation) -> TransformOperation {
    op.summary("Enable MFA for the given user.")
        .description(
            "Generates and returns a recovery code for disabling MFA in case the user loses \
             access to their MFA authenticator.\n\nAfter enabling MFA, the user is required to \
             additionally provide a valid TOTP code when logging in.",
        )
        .add_response_with::<String>(StatusCode::OK, "MFA has been enabled.", |op| {
            op.example("mfa-recovery-code")
        })
        .add_error::<MfaAlreadyEnabledError>()
        .add_error::<MfaNotInitializedError>()
        .add_error::<InvalidMfaCodeError>()
        .add_error::<UserNotFoundError>()
        .with(auth_error_docs)
        .with(internal_server_error_docs)
}

async fn disable(
    service: State<Arc<impl MfaFeatureService>>,
    token: ApiToken,
    Path(PathUserIdOrSelf { user_id }): Path<PathUserIdOrSelf>,
) -> Response {
    match service.disable(&token.0, user_id.into()).await {
        Ok(()) => Json(OkResponse).into_response(),
        Err(MfaDisableError::NotEnabled) => MfaNotEnabledError.into_response(),
        Err(MfaDisableError::NotFound) => UserNotFoundError.into_response(),
        Err(MfaDisableError::Auth(err)) => auth_error(err),
        Err(MfaDisableError::Other(err)) => internal_server_error(err),
    }
}

fn disable_docs(op: TransformOperation) -> TransformOperation {
    op.summary("Disable MFA for the given user.")
        .add_response::<OkResponse>(StatusCode::OK, "MFA has been disabled.")
        .add_error::<MfaNotEnabledError>()
        .add_error::<UserNotFoundError>()
        .with(auth_error_docs)
        .with(internal_server_error_docs)
}

error_code! {
    /// The user has already enabled MFA.
    MfaAlreadyEnabledError(CONFLICT, "MFA already enabled");
    /// MFA has not yet been initialized.
    MfaNotInitializedError(PRECONDITION_FAILED, "MFA not initialized");
    /// The TOTP code is invalid or has expired.
    pub InvalidMfaCodeError(PRECONDITION_FAILED, "Invalid code");
    /// The user has not enabled MFA.
    MfaNotEnabledError(PRECONDITION_FAILED, "MFA not enabled");
}
