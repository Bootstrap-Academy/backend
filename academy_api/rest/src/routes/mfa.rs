use std::sync::Arc;

use academy_core_mfa_contracts::{
    MfaDisableError, MfaEnableError, MfaFeatureService, MfaInitializeError,
};
use academy_models::mfa::TotpCode;
use aide::{
    axum::{routing, ApiRouter},
    transform::TransformOperation,
};
use axum::{
    extract::{Path, State},
    http::StatusCode,
    response::{IntoResponse, Response},
    Json,
};
use schemars::JsonSchema;
use serde::Deserialize;

use crate::{
    docs::TransformOperationExt,
    errors::{
        auth_error, auth_error_docs, error, internal_server_error, internal_server_error_docs,
        ApiError, InvalidCodeDetail, MfaAlreadyEnabledDetail, MfaNotEnabledDetail,
        MfaNotInitializedDetail, UserNotFoundDetail,
    },
    extractors::auth::ApiToken,
    models::{user::PathUserIdOrSelf, OkResponse},
};

pub const TAG: &str = "MFA";

pub fn router(service: Arc<impl MfaFeatureService>) -> ApiRouter<()> {
    ApiRouter::new()
        .api_route(
            "/auth/users/:user_id/mfa",
            routing::post_with(initialize, initialize_docs)
                .put_with(enable, enable_docs)
                .delete_with(disable, disable_docs),
        )
        .with_state(service)
        .with_path_items(|op| op.tag(TAG))
}

async fn initialize(
    service: State<Arc<impl MfaFeatureService>>,
    token: ApiToken,
    Path(PathUserIdOrSelf { user_id }): Path<PathUserIdOrSelf>,
) -> Response {
    match service.initialize(&token.0, user_id.into()).await {
        Ok(setup) => Json(setup.secret).into_response(),
        Err(MfaInitializeError::AlreadyEnabled) => {
            error(StatusCode::CONFLICT, MfaAlreadyEnabledDetail)
        }
        Err(MfaInitializeError::NotFound) => error(StatusCode::NOT_FOUND, UserNotFoundDetail),
        Err(MfaInitializeError::Auth(err)) => auth_error(err),
        Err(MfaInitializeError::Other(err)) => internal_server_error(err),
    }
}

fn initialize_docs(op: TransformOperation) -> TransformOperation {
    op.summary("Initialize MFA for the given user.")
        .description(
            "Generates and returns a new TOTP secret, which should be used to configure the \
             user's MFA authenticator.",
        )
        .add_response_with::<String>(StatusCode::OK, "MFA has been initialized.", |op| {
            op.example("randomtotpsecret")
        })
        .add_response::<ApiError<MfaAlreadyEnabledDetail>>(
            StatusCode::CONFLICT,
            "The user has already enabled MFA.",
        )
        .add_response::<ApiError<UserNotFoundDetail>>(
            StatusCode::NOT_FOUND,
            "The user does not exist.",
        )
        .with(auth_error_docs)
        .with(internal_server_error_docs)
}

#[derive(Deserialize, JsonSchema)]
struct EnableRequest {
    /// TOTP code generated by the MFA authenticator
    code: TotpCode,
}

async fn enable(
    service: State<Arc<impl MfaFeatureService>>,
    token: ApiToken,
    Path(PathUserIdOrSelf { user_id }): Path<PathUserIdOrSelf>,
    Json(EnableRequest { code }): Json<EnableRequest>,
) -> Response {
    match service.enable(&token.0, user_id.into(), code).await {
        Ok(recovery_code) => Json(recovery_code).into_response(),
        Err(MfaEnableError::AlreadyEnabled) => error(StatusCode::CONFLICT, MfaAlreadyEnabledDetail),
        Err(MfaEnableError::NotInitialized) => {
            error(StatusCode::PRECONDITION_FAILED, MfaNotInitializedDetail)
        }
        Err(MfaEnableError::InvalidCode) => {
            error(StatusCode::PRECONDITION_FAILED, InvalidCodeDetail)
        }
        Err(MfaEnableError::NotFound) => error(StatusCode::NOT_FOUND, UserNotFoundDetail),
        Err(MfaEnableError::Auth(err)) => auth_error(err),
        Err(MfaEnableError::Other(err)) => internal_server_error(err),
    }
}

fn enable_docs(op: TransformOperation) -> TransformOperation {
    op.summary("Enable MFA for the given user.")
        .description(
            "Generates and returns a recovery code for disabling MFA in case the user loses \
             access to their MFA authenticator.\n\nAfter enabling MFA, the user is required to \
             additionally provide a valid TOTP code when logging in.",
        )
        .add_response_with::<String>(StatusCode::OK, "MFA has been enabled.", |op| {
            op.example("mfa-recovery-code")
        })
        .add_response::<ApiError<MfaAlreadyEnabledDetail>>(
            StatusCode::CONFLICT,
            "The user has already enabled MFA.",
        )
        .add_response::<ApiError<MfaNotInitializedDetail>>(
            StatusCode::PRECONDITION_FAILED,
            "MFA has not yet been initialized.",
        )
        .add_response::<ApiError<InvalidCodeDetail>>(
            StatusCode::PRECONDITION_FAILED,
            "The TOTP code is invalid or has expired.",
        )
        .add_response::<ApiError<UserNotFoundDetail>>(
            StatusCode::NOT_FOUND,
            "The user does not exist.",
        )
        .with(auth_error_docs)
        .with(internal_server_error_docs)
}

async fn disable(
    service: State<Arc<impl MfaFeatureService>>,
    token: ApiToken,
    Path(PathUserIdOrSelf { user_id }): Path<PathUserIdOrSelf>,
) -> Response {
    match service.disable(&token.0, user_id.into()).await {
        Ok(()) => Json(OkResponse).into_response(),
        Err(MfaDisableError::NotEnabled) => {
            error(StatusCode::PRECONDITION_FAILED, MfaNotEnabledDetail)
        }
        Err(MfaDisableError::NotFound) => error(StatusCode::NOT_FOUND, "User not found"),
        Err(MfaDisableError::Auth(err)) => auth_error(err),
        Err(MfaDisableError::Other(err)) => internal_server_error(err),
    }
}

fn disable_docs(op: TransformOperation) -> TransformOperation {
    op.summary("Disable MFA for the given user.")
        .add_response::<OkResponse>(StatusCode::OK, "MFA has been disabled.")
        .add_response::<ApiError<MfaNotEnabledDetail>>(
            StatusCode::PRECONDITION_FAILED,
            "The user has not enabled MFA.",
        )
        .add_response::<ApiError<UserNotFoundDetail>>(
            StatusCode::NOT_FOUND,
            "The user does not exist.",
        )
        .with(auth_error_docs)
        .with(internal_server_error_docs)
}
